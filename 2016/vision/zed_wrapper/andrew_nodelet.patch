From c1c30800cab7a75ee67286eaf1f4263e07b871a9 Mon Sep 17 00:00:00 2001
From: Andrew Simpson <ahfergus1@gmail.com>
Date: Wed, 22 Jun 2016 19:36:06 -0400
Subject: [PATCH 1/3] New code structure with node and nodelet

---
 CMakeLists.txt     | 71 +++++++++++++++++++++++++++++++++++++++++-------------
 nodelet_zed.xml    |  9 +++++++
 package.xml        |  6 ++++-
 src/ZedDriver.cpp  | 20 +++++++++++++++
 src/ZedDriver.h    | 28 +++++++++++++++++++++
 src/ZedNode.cpp    | 23 ++++++++++++++++++
 src/ZedNodelet.cpp | 41 +++++++++++++++++++++++++++++++
 7 files changed, 180 insertions(+), 18 deletions(-)
 create mode 100644 nodelet_zed.xml
 create mode 100644 src/ZedDriver.cpp
 create mode 100644 src/ZedDriver.h
 create mode 100644 src/ZedNode.cpp
 create mode 100644 src/ZedNodelet.cpp

diff --git a/CMakeLists.txt b/CMakeLists.txt
index d5b2eff..d27c865 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -24,28 +24,38 @@ find_package(OpenCV 2.4 COMPONENTS core highgui imgproc REQUIRED)
 find_package(PCL REQUIRED)
 
 find_package(catkin REQUIRED COMPONENTS
-  image_transport
-  roscpp
-  rosconsole
-  sensor_msgs
-  cv_bridge
-  dynamic_reconfigure
+    image_transport
+    roscpp
+    rosconsole
+    sensor_msgs
+    cv_bridge
+    dynamic_reconfigure
+    nodelet
 )
 
 generate_dynamic_reconfigure_options(
-  cfg/Zed.cfg
+    cfg/Zed.cfg
 )
 
 catkin_package(
-  CATKIN_DEPENDS
+    CATKIN_DEPENDS
     roscpp
     rosconsole
     sensor_msgs
     cv_bridge
     image_transport
     dynamic_reconfigure
+    nodelet
 )
 
+
+#install(DIRECTORY include/${PROJECT_NAME}/
+#        DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION})
+install(FILES nodelet_zed.xml
+        DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION})
+install(DIRECTORY launch/
+        DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}/launch)
+
 ###############################################################################
 # INCLUDES
 
@@ -57,6 +67,7 @@ include_directories(
 	${OpenCV_INCLUDE_DIRS}
 	${PCL_INCLUDE_DIRS}
 )
+# TODO: Add boost dep.
 
 link_directories(${ZED_LIBRARY_DIR})
 link_directories(${CUDA_LIBRARY_DIRS})
@@ -70,22 +81,48 @@ link_directories(${PCL_LIBRARY_DIRS})
 
 add_definitions(-std=c++11)# -m64) #-Wall)
 
-
 add_executable(
-  zed_wrapper_node
-  src/zed_wrapper_node.cpp
+    zed_wrapper_node
+    src/zed_wrapper_node.cpp
 )
 
 target_link_libraries(
-        zed_wrapper_node
-        ${catkin_LIBRARIES}
-        ${ZED_LIBRARIES}
+    zed_wrapper_node
+    ${catkin_LIBRARIES}
+    ${ZED_LIBRARIES}
 	${CUDA_LIBRARIES} ${CUDA_nppi_LIBRARY} ${CUDA_npps_LIBRARY}
-        ${OpenCV_LIBS}
-        ${PCL_LIBRARIES}  
-    )
+    ${OpenCV_LIBS}
+    ${PCL_LIBRARIES}
+)
 
 add_dependencies(zed_wrapper_node ${PROJECT_NAME}_gencfg)
+
+
+# NEW NODE
+add_executable(zed_node src/ZedNode.cpp src/ZedDriver.cpp)
+#add_dependencies(zed_node
+#) # TODO Fix missing driver dependency
+target_link_libraries(zed_node
+    ${catkin_LIBRARIES}
+) # TODO Fix missing linked libraries
+
+# NEW NODELET
+add_library(zed_nodelet src/ZedNodelet.cpp src/ZedDriver.cpp)
+#add_dependencies(zed_nodelet) # TODO Fix deps
+target_link_libraries(zed_nodelet
+    ${catkin_LIBRARIES}
+)
+###############################################################################
+
+###############################################################################
+# INSTALL
+install(TARGETS zed_node
+        RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
+        COMPONENT main
+)
+install(TARGETS zed_nodelet
+        LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+)
 ###############################################################################
 
 #Add all files in subdirectories of the project in
diff --git a/nodelet_zed.xml b/nodelet_zed.xml
new file mode 100644
index 0000000..c982289
--- /dev/null
+++ b/nodelet_zed.xml
@@ -0,0 +1,9 @@
+<library path="lib/libdriver_nodelet"> <!-- TODO: Figure out what this is -->
+    <class name="zed_wrapper/ZedNodelet"
+           type="zed_wrapper::ZedNodelet"
+           base_class_type="nodelet::Nodelet">
+        <description>
+            Publish various ZED camera outputs to ROS.
+        </description>
+    </class>
+</library>
\ No newline at end of file
diff --git a/package.xml b/package.xml
index 7160913..c74bbfa 100644
--- a/package.xml
+++ b/package.xml
@@ -15,11 +15,12 @@
   <build_depend>sensor_msgs</build_depend>
   <!-- Recommended to pull in opencv via cv_bridge for indigo
         see: http://answers.ros.org/question/185105/add-opencv-to-indigo/ -->
-        
   <!--build_depend>opencv2</build_depend-->
   <build_depend>cv_bridge</build_depend>
   <build_depend>image_transport</build_depend>
   <build_depend>dynamic_reconfigure</build_depend>
+  <build_depend>nodelet</build_depend>
+  <build_depend>pluginlib</build_depend>
   
   <run_depend>roscpp</run_depend>
   <run_depend>rosconsole</run_depend>
@@ -28,7 +29,10 @@
   <run_depend>cv_bridge</run_depend>
   <run_depend>image_transport</run_depend>
   <run_depend>dynamic_reconfigure</run_depend>
+  <run_depend>nodelet</run_depend>
+  <run_depend>pluginlib</run_depend>
   
   <export>
+    <nodelet plugin="${prefix}/nodelet_zed.xml"/>
   </export>
 </package>
diff --git a/src/ZedDriver.cpp b/src/ZedDriver.cpp
new file mode 100644
index 0000000..dbc7449
--- /dev/null
+++ b/src/ZedDriver.cpp
@@ -0,0 +1,20 @@
+//
+// Created by andrew on 21/06/16.
+//
+
+#include <string>
+
+#include <ros/ros.h>
+
+#include "ZedDriver.h"
+
+namespace zed_driver
+{
+
+ZedDriver::ZedDriver(ros::NodeHandle node,
+                     ros::NodeHandle private_nh)
+{
+
+}
+
+} // namespace zed_driver
\ No newline at end of file
diff --git a/src/ZedDriver.h b/src/ZedDriver.h
new file mode 100644
index 0000000..2660e8a
--- /dev/null
+++ b/src/ZedDriver.h
@@ -0,0 +1,28 @@
+//
+// Created by andrew on 21/06/16.
+//
+
+#ifndef _ZED_DRIVER_H_H
+#define _ZED_DRIVER_H_H 1
+
+// Includes...
+#include <ros/ros.h>
+
+namespace zed_driver
+{
+
+class ZedDriver
+{
+public:
+    ZedDriver(ros::NodeHandle node,
+              ros::NodeHandle private_nh);
+    ~ZedDriver() {}
+
+    // Every other function that StereoLabs made should be copied here
+private:
+    
+};
+
+}
+
+#endif //_ZED_DRIVER_H_H
diff --git a/src/ZedNode.cpp b/src/ZedNode.cpp
new file mode 100644
index 0000000..9de52c6
--- /dev/null
+++ b/src/ZedNode.cpp
@@ -0,0 +1,23 @@
+//
+// Created by andrew on 21/06/16.
+//
+#include <ros/ros.h>
+#include "ZedDriver.h"
+
+int main(int argc, char** argv)
+{
+    ros::init(argc, argv, "zed_node");
+    ros::NodeHandle node;
+    ros::NodeHandle private_nh("~");
+
+    // Start driver
+    zed_driver::ZedDriver zedDriver(node, private_nh);
+
+    // Keep going until told to stop or there's a problem
+    while(ros::ok() && zedDriver.poll()) // TODO: Don't do hax polling
+    {
+        ros::spinOnce();
+    }
+
+    return 0;
+}
\ No newline at end of file
diff --git a/src/ZedNodelet.cpp b/src/ZedNodelet.cpp
new file mode 100644
index 0000000..b5deb25
--- /dev/null
+++ b/src/ZedNodelet.cpp
@@ -0,0 +1,41 @@
+//
+// Created by andrew on 21/06/16.
+//
+#include <nodelet/nodelet.h>
+#include <pluginlib/class_list_macros.h>
+
+#include DRIVER_GOES_HERE
+
+namespace zed_wrapper
+{
+
+class ZedNodelet: public nodelet::Nodelet
+{
+    ZedNodelet()
+    {
+
+    }
+
+    ~ZedNodelet()
+    {
+
+    }
+
+private:
+    virtual void onInit(void);
+    virtual void timerCb(void);
+
+    // Shared pointers go here...
+};
+
+    void ZedNodelet::onInit()
+    {
+        // Start driver
+
+        // Start polling
+    }
+}
+
+// Register with pluginlib.  Must match nodelet_zed.xml
+PLUGINLIB_DECLARE_CLASS(zed_wrapper, ZedNodelet,
+                        zed_wrapper::ZedNodelet, nodelet::Nodelet);
\ No newline at end of file
-- 
2.9.2


From 9b58289c42b1eb2b9b63770b1125524e5b59a8f6 Mon Sep 17 00:00:00 2001
From: Andrew Simpson <ahfergus1@gmail.com>
Date: Thu, 23 Jun 2016 10:38:26 -0400
Subject: [PATCH 2/3] Fixed missing point cloud members.

---
 src/ZedDriver.cpp | 338 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/ZedDriver.h   |  56 ++++++++-
 2 files changed, 392 insertions(+), 2 deletions(-)

diff --git a/src/ZedDriver.cpp b/src/ZedDriver.cpp
index dbc7449..88de5a4 100644
--- a/src/ZedDriver.cpp
+++ b/src/ZedDriver.cpp
@@ -14,7 +14,345 @@ namespace zed_driver
 ZedDriver::ZedDriver(ros::NodeHandle node,
                      ros::NodeHandle private_nh)
 {
+    // Launch file parameters
+    int resolution = sl::zed::HD720;
+    int quality = sl::zed::MODE::PERFORMANCE;
+    int sensing_mode = sl::zed::SENSING_MODE::RAW;
+    int rate = 30;
+    double max_range_m = 20; // default value for maximum depth in m
 
+    std::string img_topic = "image_rect";
+
+    // Set the default topic names
+    string rgb_topic = "rgb/" + img_topic;
+    string rgb_cam_info_topic = "rgb/camera_info";
+    string rgb_frame_id = "/zed_rgb_optical_frame";
+
+    string left_topic = "left/" + img_topic;
+    string left_cam_info_topic = "left/camera_info";
+    string left_frame_id = "/zed_left_optical_frame";
+
+    string right_topic = "right/" + img_topic;
+    string right_cam_info_topic = "right/camera_info";
+    string right_frame_id = "/zed_right_optical_frame";
+
+    string depth_topic = "depth/";
+#ifdef OPENNI_DEPTH_MODE
+    depth_topic += "image_raw";
+#else
+    depth_topic += img_topic;
+#endif
+    string depth_cam_info_topic = "depth/camera_info";
+    string depth_frame_id = "/zed_depth_optical_frame";
+
+    string point_cloud_topic = "point_cloud/" + img_topic;
+    string cloud_frame_id = "/zed_point_cloud";
+
+// TODO: Remove
+//    ros::init(argc, argv, "zed_depth_stereo_wrapper_node");
+// TODO: Put in node specific code
+    ROS_INFO("ZED_WRAPPER Node initialized");
+
+// TODO: Remove
+//    ros::NodeHandle nh;
+//    ros::NodeHandle nh_ns("~");
+
+    // Get parameters from launch file
+    private_nh.getParam("resolution", resolution);
+    private_nh.getParam("quality", quality);
+    private_nh.getParam("sensing_mode", sensing_mode);
+    private_nh.getParam("frame_rate", rate);
+    private_nh.getParam("max_range", max_range_m);
+
+    private_nh.getParam("rgb_topic", rgb_topic);
+    private_nh.getParam("rgb_cam_info_topic", rgb_cam_info_topic);
+    private_nh.getParam("rgb_frame_id", rgb_frame_id);
+
+    private_nh.getParam("left_topic", left_topic);
+    private_nh.getParam("left_cam_info_topic", left_cam_info_topic);
+    private_nh.getParam("left_frame_id", left_frame_id);
+
+    private_nh.getParam("right_topic", right_topic);
+    private_nh.getParam("right_cam_info_topic", right_cam_info_topic);
+    private_nh.getParam("right_frame_id", right_frame_id);
+
+    private_nh.getParam("depth_topic", depth_topic);
+    private_nh.getParam("depth_cam_info_topic", depth_cam_info_topic);
+    private_nh.getParam("depth_frame_id", depth_frame_id);
+
+    private_nh.getParam("point_cloud_topic", point_cloud_topic);
+    private_nh.getParam("cloud_frame_id", cloud_frame_id);
+
+    // TODO: Reimplement SVO support somehow
+    // Create the ZED object
+    std::unique_ptr<sl::zed::Camera> zed;
+//    if (argc == 2) {
+//        zed.reset(new sl::zed::Camera(argv[1])); // Argument "svo_file" in launch file
+//        ROS_INFO_STREAM("Reading SVO file : " << argv[1]);
+//    } else {
+        zed.reset(new sl::zed::Camera(static_cast<sl::zed::ZEDResolution_mode> (resolution), rate));
+        ROS_INFO_STREAM("Using ZED Camera");
+//    }
+
+    // Try to initialize the ZED
+    ERRCODE err = ERRCODE::ZED_NOT_AVAILABLE;
+    while (err != SUCCESS) {
+        err = zed->init(static_cast<sl::zed::MODE> (quality), -1, true);
+        ROS_INFO_STREAM(errcode2str(err));
+        std::this_thread::sleep_for(std::chrono::milliseconds(2000));
+    }
+
+    //ERRCODE display
+    dynamic_reconfigure::Server<zed_ros_wrapper::ZedConfig> server;
+    dynamic_reconfigure::Server<zed_ros_wrapper::ZedConfig>::CallbackType f;
+
+    // TODO: Do this this in a non-specific way to Nodes/Nodelets
+    f = boost::bind(&callback, _1, _2);
+    server.setCallback(f);
+    confidence = 80;
+
+    // Set the maximum range of the ZED camera (TNO addition)
+    if (max_range_m > 1.0)
+    {
+        // Distance must be provided in mm
+        zed->setDepthClampValue(max_range_m*1000);
+    }
+    else
+    {
+        ROS_WARN("You have set the max disparity range for the ZED camera to %f m, ignoring this low value", max_range_m);
+    }
+
+    // Get the parameters of the ZED images
+    int width = zed->getImageSize().width;
+    int height = zed->getImageSize().height;
+    ROS_DEBUG_STREAM("Image size : " << width << "x" << height);
+
+    cv::Size cvSize(width, height);
+    cv::Mat leftImRGB(cvSize, CV_8UC3);
+    cv::Mat rightImRGB(cvSize, CV_8UC3);
+    cv::Mat depthIm;
+
+    // Create all the publishers
+    // Image publishers
+    image_transport::ImageTransport it_zed(node);
+    image_transport::Publisher pub_rgb = it_zed.advertise(rgb_topic, 1); //rgb
+    ROS_INFO_STREAM("Advertized on topic " << rgb_topic);
+    image_transport::Publisher pub_left = it_zed.advertise(left_topic, 1); //left
+    ROS_INFO_STREAM("Advertized on topic " << left_topic);
+    image_transport::Publisher pub_right = it_zed.advertise(right_topic, 1); //right
+    ROS_INFO_STREAM("Advertized on topic " << right_topic);
+    image_transport::Publisher pub_depth = it_zed.advertise(depth_topic, 1); //depth
+    ROS_INFO_STREAM("Advertized on topic " << depth_topic);
+
+    //PointCloud publisher
+    ros::Publisher pub_cloud = node.advertise<sensor_msgs::PointCloud2> (point_cloud_topic, 1);
+    ROS_INFO_STREAM("Advertized on topic " << point_cloud_topic);
+
+    // Camera info publishers
+    ros::Publisher pub_rgb_cam_info = node.advertise<sensor_msgs::CameraInfo>(rgb_cam_info_topic, 1); //rgb
+    ROS_INFO_STREAM("Advertized on topic " << rgb_cam_info_topic);
+    ros::Publisher pub_left_cam_info = node.advertise<sensor_msgs::CameraInfo>(left_cam_info_topic, 1); //left
+    ROS_INFO_STREAM("Advertized on topic " << left_cam_info_topic);
+    ros::Publisher pub_right_cam_info = node.advertise<sensor_msgs::CameraInfo>(right_cam_info_topic, 1); //right
+    ROS_INFO_STREAM("Advertized on topic " << right_cam_info_topic);
+    ros::Publisher pub_depth_cam_info = node.advertise<sensor_msgs::CameraInfo>(depth_cam_info_topic, 1); //depth
+    ROS_INFO_STREAM("Advertized on topic " << depth_cam_info_topic);
+
+    // Create and fill the camera information messages
+    sensor_msgs::CameraInfoPtr rgb_cam_info_msg(new sensor_msgs::CameraInfo());
+    sensor_msgs::CameraInfoPtr left_cam_info_msg(new sensor_msgs::CameraInfo());
+    sensor_msgs::CameraInfoPtr right_cam_info_msg(new sensor_msgs::CameraInfo());
+    sensor_msgs::CameraInfoPtr depth_cam_info_msg(new sensor_msgs::CameraInfo());
+    fillCamInfo(zed.get(), left_cam_info_msg, right_cam_info_msg, left_frame_id, right_frame_id);
+    rgb_cam_info_msg = depth_cam_info_msg = left_cam_info_msg; // the reference camera is the Left one (next to the ZED logo)
+
+    // TODO: Be Node/Nodelet neutral
+    ros::Rate loop_rate(rate);
+    ros::Time old_t = ros::Time::now();
+    bool old_image = false;
+    std::unique_ptr<std::thread> pointCloudThread = nullptr;
+    pointCloudThread.reset(new std::thread(&publishPointCloud, width, height, std::ref(pub_cloud)));
+}
+
+int ZedDriver::poll(int argc, char **argv)
+{
+
+}
+
+/* \brief Publish a cv::Mat image with a ros Publisher
+ * \param img : the image to publish
+ * \param pub_img : the publisher object to use
+ * \param img_frame_id : the id of the reference frame of the image
+ * \param t : the ros::Time to stamp the image
+ */
+void ZedDriver::publishImage(cv::Mat img, image_transport::Publisher &pub_img, string img_frame_id,
+                             ros::Time t)
+{
+    cv_bridge::CvImage img_im;
+    img_im.image = img;
+    img_im.encoding = sensor_msgs::image_encodings::BGR8;
+    img_im.header.frame_id = img_frame_id;
+    img_im.header.stamp = t;
+    pub_img.publish(img_im.toImageMsg());
+}
+
+/* \brief Publish a cv::Mat depth image with a ros Publisher
+ * \param depth : the depth image to publish
+ * \param pub_depth : the publisher object to use
+ * \param depth_frame_id : the id of the reference frame of the depth image
+ * \param t : the ros::Time to stamp the depth image
+ */
+void ZedDriver::publishDepth(cv::Mat depth, image_transport::Publisher &pub_depth,
+                             string depth_frame_id, ros::Time t)
+{
+    cv_bridge::CvImage depth_im;
+    depth_im.image = depth;
+#ifdef OPENNI_DEPTH_MODE
+    depth_im.encoding = sensor_msgs::image_encodings::TYPE_16UC1;
+#else
+    depth_im.encoding = sensor_msgs::image_encodings::TYPE_32FC1;
+#endif
+    depth_im.header.frame_id = depth_frame_id;
+    depth_im.header.stamp = t;
+    pub_depth.publish(depth_im.toImageMsg());
+}
+
+/* \brief Publish a pointCloud with a ros Publisher
+ * \param p_could : the float pointer to point cloud datas
+ * \param width : the width of the point cloud
+ * \param height : the height of the point cloud
+ * \param pub_cloud : the publisher object to use
+ * \param cloud_frame_id : the id of the reference frame of the point cloud
+ * \param t : the ros::Time to stamp the point cloud
+ */
+void ZedDriver::publishPointCloud(int width, int height, ros::Publisher &pub_cloud)
+{
+    while (pointCloudThreadRunning) { // check if the thread has to continue
+        if (!point_cloud_data_processing) { // check if datas are available
+            std::this_thread::sleep_for(std::chrono::milliseconds(5)); // No data, we just wait
+            continue;
+        }
+        pcl::PointCloud<pcl::PointXYZRGB> point_cloud;
+        point_cloud.width = width;
+        point_cloud.height = height;
+        int size = width*height;
+        point_cloud.points.resize(size);
+        int index4 = 0;
+        float color;
+        for (int i = 0; i < size; i++) {
+            if (cloud[index4 + 2] < 0) { // Check if it's an unvalid point, the depth is lower than 0
+                index4 += 4;
+                continue;
+            }
+            point_cloud.points[i].y = -cloud[index4++] * 0.001;
+            point_cloud.points[i].z = -cloud[index4++] * 0.001;
+            point_cloud.points[i].x = cloud[index4++] * 0.001;
+            color = cloud[index4++];
+            uint32_t color_uint = *(uint32_t*) & color; // Convert the color
+            unsigned char* color_uchar = (unsigned char*) &color_uint;
+            color_uint = ((uint32_t) color_uchar[0] << 16 | (uint32_t) color_uchar[1] << 8 | (uint32_t) color_uchar[2]);
+            point_cloud.points[i].rgb = *reinterpret_cast<float*> (&color_uint);
+        }
+        sensor_msgs::PointCloud2 output;
+        pcl::toROSMsg(point_cloud, output); // Convert the point cloud to a ROS message
+        output.header.frame_id = point_cloud_frame_id; // Set the header values of the ROS message
+        output.header.stamp = point_cloud_time;
+        pub_cloud.publish(output);
+        point_cloud_data_processing = false;
+    }
+}
+
+/* \brief Publish the informations of a camera with a ros Publisher
+ * \param cam_info_msg : the information message to publish
+ * \param pub_cam_info : the publisher object to use
+ * \param t : the ros::Time to stamp the message
+ */
+void ZedDriver::publishCamInfo(sensor_msgs::CameraInfoPtr cam_info_msg, ros::Publisher pub_cam_info,
+                               ros::Time t)
+{
+    static int seq = 0;
+    cam_info_msg->header.stamp = t;
+    cam_info_msg->header.seq = seq;
+    pub_cam_info.publish(cam_info_msg);
+    seq++;
+}
+
+/* \brief Get the information of the ZED cameras and store them in an information message
+ * \param zed : the sl::zed::Camera* pointer to an instance
+ * \param left_cam_info_msg : the information message to fill with the left camera informations
+ * \param right_cam_info_msg : the information message to fill with the right camera informations
+ * \param left_frame_id : the id of the reference frame of the left camera
+ * \param right_frame_id : the id of the reference frame of the right camera
+ */
+void ZedDriver::fillCamInfo(Camera *zed, sensor_msgs::CameraInfoPtr left_cam_info_msg,
+                            sensor_msgs::CameraInfoPtr right_cam_info_msg, string left_frame_id,
+                            string right_frame_id)
+{
+    int width = zed->getImageSize().width;
+    int height = zed->getImageSize().height;
+
+    sl::zed::StereoParameters* zedParam = zed->getParameters();
+
+    float baseline = zedParam->baseline;
+
+    float fx = zedParam->LeftCam.fx;
+    float fy = zedParam->LeftCam.fy;
+    float cx = zedParam->LeftCam.cx;
+    float cy = zedParam->LeftCam.cy;
+
+    // There is no distorsions since the images are rectified
+    double k1 = 0;
+    double k2 = 0;
+    double k3 = 0;
+    double p1 = 0;
+    double p2 = 0;
+
+    left_cam_info_msg->distortion_model = sensor_msgs::distortion_models::PLUMB_BOB;
+    right_cam_info_msg->distortion_model = sensor_msgs::distortion_models::PLUMB_BOB;
+
+    left_cam_info_msg->D.resize(5);
+    right_cam_info_msg->D.resize(5);
+    left_cam_info_msg->D[0] = right_cam_info_msg->D[0] = k1;
+    left_cam_info_msg->D[1] = right_cam_info_msg->D[1] = k2;
+    left_cam_info_msg->D[2] = right_cam_info_msg->D[2] = k3;
+    left_cam_info_msg->D[3] = right_cam_info_msg->D[3] = p1;
+    left_cam_info_msg->D[4] = right_cam_info_msg->D[4] = p2;
+
+    left_cam_info_msg->K.fill(0.0);
+    right_cam_info_msg->K.fill(0.0);
+    left_cam_info_msg->K[0] = right_cam_info_msg->K[0] = fx;
+    left_cam_info_msg->K[2] = right_cam_info_msg->K[2] = cx;
+    left_cam_info_msg->K[4] = right_cam_info_msg->K[4] = fy;
+    left_cam_info_msg->K[5] = right_cam_info_msg->K[5] = cy;
+    left_cam_info_msg->K[8] = right_cam_info_msg->K[8] = 1.0;
+
+    left_cam_info_msg->R.fill(0.0);
+    right_cam_info_msg->R.fill(0.0);
+
+    left_cam_info_msg->P.fill(0.0);
+    right_cam_info_msg->P.fill(0.0);
+    left_cam_info_msg->P[0] = right_cam_info_msg->P[0] = fx;
+    left_cam_info_msg->P[2] = right_cam_info_msg->P[2] = cx;
+    left_cam_info_msg->P[5] = right_cam_info_msg->P[5] = fy;
+    left_cam_info_msg->P[6] = right_cam_info_msg->P[6] = cy;
+    left_cam_info_msg->P[10] = right_cam_info_msg->P[10] = 1.0;
+    right_cam_info_msg->P[3] = (-1 * fx * (baseline / 1000));
+
+    left_cam_info_msg->width = right_cam_info_msg->width = width;
+    left_cam_info_msg->height = right_cam_info_msg->height = height;
+
+    left_cam_info_msg->header.frame_id = left_frame_id;
+    right_cam_info_msg->header.frame_id = right_frame_id;
+}
+
+/* \brief Callback for dynamic reconfigure
+ * \param config : Dunno
+ * \param level  : Dunno, unused
+ */
+void ZedDriver::callback(zed_ros_wrapper::ZedConfig &config, uint32_t level)
+{
+    ROS_INFO("Reconfigure confidence : %d", config.confidence);
+    confidence = config.confidence;
 }
 
 } // namespace zed_driver
\ No newline at end of file
diff --git a/src/ZedDriver.h b/src/ZedDriver.h
index 2660e8a..a55b4af 100644
--- a/src/ZedDriver.h
+++ b/src/ZedDriver.h
@@ -5,8 +5,43 @@
 #ifndef _ZED_DRIVER_H_H
 #define _ZED_DRIVER_H_H 1
 
-// Includes...
+// Standard includes
+#include <csignal>
+#include <cstdio>
+//#include <math.h>
+#include <limits>
+#include <thread>
+//#include <chrono>
+//#include <memory>
+
+// ROS includes
 #include <ros/ros.h>
+#include <sensor_msgs/Image.h>
+#include <sensor_msgs/CameraInfo.h>
+#include <sensor_msgs/distortion_models.h>
+#include <cv_bridge/cv_bridge.h>
+//#include <sensor_msgs/image_encodings.h>
+#include <image_transport/image_transport.h>
+#include <dynamic_reconfigure/server.h>
+#include <zed_ros_wrapper/ZedConfig.h>
+
+// OpenCV includes
+//#include <opencv2/core/core.hpp>
+#include <opencv2/highgui/highgui.hpp>
+//#include <opencv2/imgproc/imgproc.hpp>
+#include <opencv2/calib3d/calib3d.hpp>
+
+//PCL includes
+#include <sensor_msgs/PointCloud2.h>
+#include <pcl_conversions/pcl_conversions.h>
+//#include <pcl/point_cloud.h>
+//#include <pcl/point_types.h>
+
+// ZED Includes
+#include <zed/Camera.hpp>
+
+using namespace sl::zed;
+using namespace std;
 
 namespace zed_driver
 {
@@ -17,10 +52,27 @@ public:
     ZedDriver(ros::NodeHandle node,
               ros::NodeHandle private_nh);
     ~ZedDriver() {}
+    int poll(int argc, char **argv);
 
     // Every other function that StereoLabs made should be copied here
 private:
-    
+    // Depth variables
+    int confidence;
+    bool computeDepth;
+    // Point cloud thread variables
+    float* cloud;
+    bool pointCloudThreadRunning = true;
+    bool point_cloud_data_processing = false;
+    string point_cloud_frame_id = "";
+    ros::Time point_cloud_time;
+    // Functions
+    void publishImage(cv::Mat img, image_transport::Publisher &pub_img, string img_frame_id, ros::Time t);
+    void publishDepth(cv::Mat depth, image_transport::Publisher &pub_depth, string depth_frame_id, ros::Time t);
+    void publishPointCloud(int width, int height, ros::Publisher &pub_cloud);
+    void publishCamInfo(sensor_msgs::CameraInfoPtr cam_info_msg, ros::Publisher pub_cam_info, ros::Time t);
+    void fillCamInfo(Camera* zed, sensor_msgs::CameraInfoPtr left_cam_info_msg, sensor_msgs::CameraInfoPtr right_cam_info_msg,
+                     string left_frame_id, string right_frame_id);
+    void callback(zed_ros_wrapper::ZedConfig &config, uint32_t level);
 };
 
 }
-- 
2.9.2


From 9b064cd86ef0dfddf27019199f4b52fa56aa4ade Mon Sep 17 00:00:00 2001
From: Andrew Simpson <ahfergus1@gmail.com>
Date: Wed, 29 Jun 2016 23:58:43 -0400
Subject: [PATCH 3/3] Init finished, poll mostly finished

---
 src/ZedDriver.cpp | 188 +++++++++++++++++++++++++++++++++++++++++++-----------
 src/ZedDriver.h   |  42 +++++++++++-
 2 files changed, 193 insertions(+), 37 deletions(-)

diff --git a/src/ZedDriver.cpp b/src/ZedDriver.cpp
index 88de5a4..214ad70 100644
--- a/src/ZedDriver.cpp
+++ b/src/ZedDriver.cpp
@@ -12,13 +12,13 @@ namespace zed_driver
 {
 
 ZedDriver::ZedDriver(ros::NodeHandle node,
-                     ros::NodeHandle private_nh)
+                     ros::NodeHandle private_nh): it_zed(node)
 {
     // Launch file parameters
-    int resolution = sl::zed::HD720;
-    int quality = sl::zed::MODE::PERFORMANCE;
-    int sensing_mode = sl::zed::SENSING_MODE::RAW;
-    int rate = 30;
+    resolution = sl::zed::HD720;
+    quality = sl::zed::MODE::PERFORMANCE;
+    sensing_mode = sl::zed::SENSING_MODE::RAW;
+    rate = 30;
     double max_range_m = 20; // default value for maximum depth in m
 
     std::string img_topic = "image_rect";
@@ -26,15 +26,15 @@ ZedDriver::ZedDriver(ros::NodeHandle node,
     // Set the default topic names
     string rgb_topic = "rgb/" + img_topic;
     string rgb_cam_info_topic = "rgb/camera_info";
-    string rgb_frame_id = "/zed_rgb_optical_frame";
+    rgb_frame_id = "/zed_rgb_optical_frame";
 
     string left_topic = "left/" + img_topic;
     string left_cam_info_topic = "left/camera_info";
-    string left_frame_id = "/zed_left_optical_frame";
+    left_frame_id = "/zed_left_optical_frame";
 
     string right_topic = "right/" + img_topic;
     string right_cam_info_topic = "right/camera_info";
-    string right_frame_id = "/zed_right_optical_frame";
+    right_frame_id = "/zed_right_optical_frame";
 
     string depth_topic = "depth/";
 #ifdef OPENNI_DEPTH_MODE
@@ -43,10 +43,10 @@ ZedDriver::ZedDriver(ros::NodeHandle node,
     depth_topic += img_topic;
 #endif
     string depth_cam_info_topic = "depth/camera_info";
-    string depth_frame_id = "/zed_depth_optical_frame";
+    depth_frame_id = "/zed_depth_optical_frame";
 
     string point_cloud_topic = "point_cloud/" + img_topic;
-    string cloud_frame_id = "/zed_point_cloud";
+    cloud_frame_id = "/zed_point_cloud";
 
 // TODO: Remove
 //    ros::init(argc, argv, "zed_depth_stereo_wrapper_node");
@@ -83,9 +83,9 @@ ZedDriver::ZedDriver(ros::NodeHandle node,
     private_nh.getParam("point_cloud_topic", point_cloud_topic);
     private_nh.getParam("cloud_frame_id", cloud_frame_id);
 
-    // TODO: Reimplement SVO support somehow
+    // TODO: Re-implement SVO support somehow
     // Create the ZED object
-    std::unique_ptr<sl::zed::Camera> zed;
+//    std::unique_ptr<sl::zed::Camera> zed;
 //    if (argc == 2) {
 //        zed.reset(new sl::zed::Camera(argv[1])); // Argument "svo_file" in launch file
 //        ROS_INFO_STREAM("Reading SVO file : " << argv[1]);
@@ -102,13 +102,15 @@ ZedDriver::ZedDriver(ros::NodeHandle node,
         std::this_thread::sleep_for(std::chrono::milliseconds(2000));
     }
 
+    // Initialize dynamic reconfigure
     //ERRCODE display
-    dynamic_reconfigure::Server<zed_ros_wrapper::ZedConfig> server;
+//    dynamic_reconfigure::Server<zed_ros_wrapper::ZedConfig> server;
+    server = boost::make_shared<dynamic_reconfigure::Server<zed_ros_wrapper::ZedConfig>>(private_nh);
     dynamic_reconfigure::Server<zed_ros_wrapper::ZedConfig>::CallbackType f;
 
     // TODO: Do this this in a non-specific way to Nodes/Nodelets
-    f = boost::bind(&callback, _1, _2);
-    server.setCallback(f);
+    f = boost::bind(&callback, this, _1, _2);
+    server->setCallback(f);
     confidence = 80;
 
     // Set the maximum range of the ZED camera (TNO addition)
@@ -127,56 +129,170 @@ ZedDriver::ZedDriver(ros::NodeHandle node,
     int height = zed->getImageSize().height;
     ROS_DEBUG_STREAM("Image size : " << width << "x" << height);
 
-    cv::Size cvSize(width, height);
-    cv::Mat leftImRGB(cvSize, CV_8UC3);
-    cv::Mat rightImRGB(cvSize, CV_8UC3);
-    cv::Mat depthIm;
+    cvSize = cv::Size(width, height);
 
     // Create all the publishers
     // Image publishers
-    image_transport::ImageTransport it_zed(node);
-    image_transport::Publisher pub_rgb = it_zed.advertise(rgb_topic, 1); //rgb
+//    image_transport::ImageTransport it_zed(node);
+//    image_transport::Publisher pub_rgb = it_zed.advertise(rgb_topic, 1); //rgb
+    pub_rgb = it_zed.advertise(rgb_topic, 1); //rgb
     ROS_INFO_STREAM("Advertized on topic " << rgb_topic);
-    image_transport::Publisher pub_left = it_zed.advertise(left_topic, 1); //left
+    pub_left = it_zed.advertise(left_topic, 1); //left
     ROS_INFO_STREAM("Advertized on topic " << left_topic);
-    image_transport::Publisher pub_right = it_zed.advertise(right_topic, 1); //right
+    pub_right = it_zed.advertise(right_topic, 1); //right
     ROS_INFO_STREAM("Advertized on topic " << right_topic);
-    image_transport::Publisher pub_depth = it_zed.advertise(depth_topic, 1); //depth
+    pub_depth = it_zed.advertise(depth_topic, 1); //depth
     ROS_INFO_STREAM("Advertized on topic " << depth_topic);
 
     //PointCloud publisher
-    ros::Publisher pub_cloud = node.advertise<sensor_msgs::PointCloud2> (point_cloud_topic, 1);
+    pub_cloud = node.advertise<sensor_msgs::PointCloud2> (point_cloud_topic, 1);
     ROS_INFO_STREAM("Advertized on topic " << point_cloud_topic);
 
     // Camera info publishers
-    ros::Publisher pub_rgb_cam_info = node.advertise<sensor_msgs::CameraInfo>(rgb_cam_info_topic, 1); //rgb
+    pub_rgb_cam_info = node.advertise<sensor_msgs::CameraInfo>(rgb_cam_info_topic, 1); //rgb
     ROS_INFO_STREAM("Advertized on topic " << rgb_cam_info_topic);
-    ros::Publisher pub_left_cam_info = node.advertise<sensor_msgs::CameraInfo>(left_cam_info_topic, 1); //left
+    pub_left_cam_info = node.advertise<sensor_msgs::CameraInfo>(left_cam_info_topic, 1); //left
     ROS_INFO_STREAM("Advertized on topic " << left_cam_info_topic);
-    ros::Publisher pub_right_cam_info = node.advertise<sensor_msgs::CameraInfo>(right_cam_info_topic, 1); //right
+    pub_right_cam_info = node.advertise<sensor_msgs::CameraInfo>(right_cam_info_topic, 1); //right
     ROS_INFO_STREAM("Advertized on topic " << right_cam_info_topic);
-    ros::Publisher pub_depth_cam_info = node.advertise<sensor_msgs::CameraInfo>(depth_cam_info_topic, 1); //depth
+    pub_depth_cam_info = node.advertise<sensor_msgs::CameraInfo>(depth_cam_info_topic, 1); //depth
     ROS_INFO_STREAM("Advertized on topic " << depth_cam_info_topic);
 
     // Create and fill the camera information messages
-    sensor_msgs::CameraInfoPtr rgb_cam_info_msg(new sensor_msgs::CameraInfo());
-    sensor_msgs::CameraInfoPtr left_cam_info_msg(new sensor_msgs::CameraInfo());
-    sensor_msgs::CameraInfoPtr right_cam_info_msg(new sensor_msgs::CameraInfo());
-    sensor_msgs::CameraInfoPtr depth_cam_info_msg(new sensor_msgs::CameraInfo());
+    rgb_cam_info_msg = sensor_msgs::CameraInfoPtr(new sensor_msgs::CameraInfo());
+    left_cam_info_msg = sensor_msgs::CameraInfoPtr(new sensor_msgs::CameraInfo());
+    right_cam_info_msg = sensor_msgs::CameraInfoPtr(new sensor_msgs::CameraInfo());
+    depth_cam_info_msg = sensor_msgs::CameraInfoPtr(new sensor_msgs::CameraInfo());
     fillCamInfo(zed.get(), left_cam_info_msg, right_cam_info_msg, left_frame_id, right_frame_id);
     rgb_cam_info_msg = depth_cam_info_msg = left_cam_info_msg; // the reference camera is the Left one (next to the ZED logo)
 
     // TODO: Be Node/Nodelet neutral
     ros::Rate loop_rate(rate);
-    ros::Time old_t = ros::Time::now();
-    bool old_image = false;
+    old_t = ros::Time::now();
+    old_image = false;
     std::unique_ptr<std::thread> pointCloudThread = nullptr;
     pointCloudThread.reset(new std::thread(&publishPointCloud, width, height, std::ref(pub_cloud)));
 }
 
-int ZedDriver::poll(int argc, char **argv)
+/* \brief Check if a new fram is available
+ *
+ */
+bool ZedDriver::poll(void)
 {
+    // Check for subscribers
+    int rgb_SubNumber = pub_rgb.getNumSubscribers();
+    int left_SubNumber = pub_left.getNumSubscribers();
+    int right_SubNumber = pub_right.getNumSubscribers();
+    int depth_SubNumber = pub_depth.getNumSubscribers();
+    int cloud_SubNumber = pub_cloud.getNumSubscribers();
+    bool run = (rgb_SubNumber + left_SubNumber + right_SubNumber + depth_SubNumber + cloud_SubNumber) > 0;
+
+    // TODO: Only reserve if needed
+    cv::Mat depthIm;
+
+    // Run the loop only if there is some subscribers
+    if (run) {
+        computeDepth = (depth_SubNumber + cloud_SubNumber) > 0; // Detect if one of the subscriber need to have the depth information
+        ros::Time t = ros::Time::now(); // Get current time
+
+        if (computeDepth) {
+            int actual_confidence = zed->getConfidenceThreshold();
+            if (actual_confidence != confidence)
+                zed->setConfidenceThreshold(confidence);
+            old_image = zed->grab(static_cast<sl::zed::SENSING_MODE> (sensing_mode), true, true); // Ask to compute the depth
+        } else
+            old_image = zed->grab(static_cast<sl::zed::SENSING_MODE> (sensing_mode), false, false); // Ask to not compute the depth
+
+
+        if (old_image) { // Detect if a error occurred (for example: the zed have been disconnected) and re-initialize the ZED
+            ROS_WARN("Wait for a new image to proceed");
+            // TODO: Don't sleep, it's hacky
+            std::this_thread::sleep_for(std::chrono::milliseconds(2));
+            // t is time in seconds
+            if ((t - old_t).toSec() > 5) {
+                // delete the old object before constructing a new one
+                zed.reset();
+                if (argc == 2) {
+                    zed.reset(new sl::zed::Camera(argv[1])); // Argument "svo_file" in launch file
+                    ROS_INFO_STREAM("Reading SVO file : " << argv[1]);
+                } else {
+                    zed.reset(new sl::zed::Camera(static_cast<sl::zed::ZEDResolution_mode> (resolution), rate));
+                    ROS_INFO_STREAM("Using ZED Camera");
+                }
+                ROS_INFO("Reinit camera");
+                ERRCODE err = ERRCODE::ZED_NOT_AVAILABLE;
+                while (err != SUCCESS) {
+                    err = zed->init(static_cast<sl::zed::MODE> (quality), -1, true); // Try to initialize the ZED
+                    ROS_INFO_STREAM(errcode2str(err));
+                    std::this_thread::sleep_for(std::chrono::milliseconds(2000));
+                }
+            }
+            // TODO: Remove
+            // continue;
+            return false;
+        }
+
+        old_t = ros::Time::now();
+
+        // Publish the left == rgb image if someone has subscribed to
+        if (left_SubNumber > 0 || rgb_SubNumber > 0) {
+            // Retrieve RGBA Left image
+            cv::Mat leftImRGB(cvSize, CV_8UC3);
+            cv::cvtColor(slMat2cvMat(zed->retrieveImage(sl::zed::SIDE::LEFT)), leftImRGB, CV_RGBA2RGB); // Convert to RGB
+            if (left_SubNumber > 0) {
+                publishCamInfo(left_cam_info_msg, pub_left_cam_info, t);
+                publishImage(leftImRGB, pub_left, left_frame_id, t);
+            }
+            if (rgb_SubNumber > 0) {
+                publishCamInfo(rgb_cam_info_msg, pub_rgb_cam_info, t);
+                publishImage(leftImRGB, pub_rgb, rgb_frame_id, t); // rgb is the left image
+            }
+        }
+
+        // Publish the right image if someone has subscribed to
+        if (right_SubNumber > 0) {
+            // Retrieve RGBA Right image
+            cv::Mat rightImRGB(cvSize, CV_8UC3);
+            cv::cvtColor(slMat2cvMat(zed->retrieveImage(sl::zed::SIDE::RIGHT)), rightImRGB, CV_RGBA2RGB); // Convert to RGB
+            publishCamInfo(right_cam_info_msg, pub_right_cam_info, t);
+            publishImage(rightImRGB, pub_right, right_frame_id, t);
+        }
 
+        // Publish the depth image if someone has subscribed to
+        if (depth_SubNumber > 0) {
+            publishCamInfo(depth_cam_info_msg, pub_depth_cam_info, t);
+#ifdef OPENNI_DEPTH_MODE
+            // Retrieve raw depth data and convert it to 16_bit data
+                    slMat2cvMat(zed->retrieveMeasure(sl::zed::MEASURE::DEPTH)).convertTo(depthIm, CV_16UC1); // in mm, rounded
+                    publishDepth(depthIm, pub_depth, depth_frame_id, t);
+#else
+            publishDepth(slMat2cvMat(zed->retrieveMeasure(sl::zed::MEASURE::DEPTH))*0.001, pub_depth, depth_frame_id, t); // in meters
+#endif
+        }
+
+        // Publish the point cloud if someone has subscribed to
+        if (cloud_SubNumber > 0 && point_cloud_data_processing == false) {
+            // Run the point cloud convertion asynchronously to avoid slowing down all the program
+            // Retrieve raw pointCloud data
+            cloud = (float*) zed->retrieveMeasure(sl::zed::MEASURE::XYZRGBA).data;
+            point_cloud_frame_id = cloud_frame_id;
+            point_cloud_time = t;
+            point_cloud_data_processing = true;
+        }
+
+        // TODO: Move to node - driver doesn't do timing
+//        ros::spinOnce();
+//        loop_rate.sleep();
+    }
+    else
+    {
+        //TODO: Remove
+//        // No subscribers, we just wait
+//        std::this_thread::sleep_for(std::chrono::milliseconds(10));
+
+        // Return
+        return 0;
+    }
 }
 
 /* \brief Publish a cv::Mat image with a ros Publisher
diff --git a/src/ZedDriver.h b/src/ZedDriver.h
index a55b4af..07ea36c 100644
--- a/src/ZedDriver.h
+++ b/src/ZedDriver.h
@@ -52,7 +52,7 @@ public:
     ZedDriver(ros::NodeHandle node,
               ros::NodeHandle private_nh);
     ~ZedDriver() {}
-    int poll(int argc, char **argv);
+    bool poll(void);
 
     // Every other function that StereoLabs made should be copied here
 private:
@@ -65,6 +65,46 @@ private:
     bool point_cloud_data_processing = false;
     string point_cloud_frame_id = "";
     ros::Time point_cloud_time;
+    std::unique_ptr<sl::zed::Camera> zed;
+    boost::shared_ptr<dynamic_reconfigure::Server<zed_ros_wrapper::ZedConfig>>
+            server;
+
+    // Image parameters
+    int resolution;
+    int quality;
+    int sensing_mode;
+    int rate;
+    cv::Size cvSize;
+
+    // Frame ids
+    string rgb_frame_id;
+    string left_frame_id;
+    string right_frame_id;
+    string depth_frame_id;
+    string cloud_frame_id;
+
+    // Publishers
+    image_transport::ImageTransport it_zed;
+    image_transport::Publisher pub_rgb;
+    image_transport::Publisher pub_left;
+    image_transport::Publisher pub_right;
+    image_transport::Publisher pub_depth;
+    ros::Publisher pub_cloud;
+    ros::Publisher pub_rgb_cam_info;
+    ros::Publisher pub_left_cam_info;
+    ros::Publisher pub_right_cam_info;
+    ros::Publisher pub_depth_cam_info;
+
+    // Info messages - don't change between iterations
+    sensor_msgs::CameraInfoPtr rgb_cam_info_msg;
+    sensor_msgs::CameraInfoPtr left_cam_info_msg;
+    sensor_msgs::CameraInfoPtr right_cam_info_msg;
+    sensor_msgs::CameraInfoPtr depth_cam_info_msg;
+
+    // Poll parameters
+    ros::Time old_t;
+    bool old_image;
+
     // Functions
     void publishImage(cv::Mat img, image_transport::Publisher &pub_img, string img_frame_id, ros::Time t);
     void publishDepth(cv::Mat depth, image_transport::Publisher &pub_depth, string depth_frame_id, ros::Time t);
-- 
2.9.2

